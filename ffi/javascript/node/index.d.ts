/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * Generates Nemesis behaviors for given mod IDs using a configuration.
 *
 * - nemesis_paths: `e.g. ["../../dummy/Data/Nemesis_Engine/mod/aaaaa"]`
 * - `config.resource_dir`: Path of the template from which the patch was applied.(e.g. `../templates/` => `../templates/meshes`)
 * - `status_fn` - Optional thread_safe JS callback for patch status updates.
 *
 * # Errors
 * Returns an error if file parsing, I/O operations, or JSON serialization fails.
 */
export declare function behaviorGen(nemesis_paths: PatchMaps, config: Config, status_fn?: (err: Error | null, status: PatchStatus) => void): Promise<void>

/**
 * Changes the current logging level.
 *
 * # Errors
 * If logger uninitialized.
 *
 * # Examples
 * ```ts
 * changeLogLevel('debug'); // Supported: "trace" | "debug" | "info" | "warn" | "error"
 * ```
 *
 * # Note
 * - If unknown log level. fallback to `error`.(And write log warn)
 * - `level` - Logging level as a string. Supported values: `"trace"`, `"debug"`, `"info"`, `"warn"`, `"error"`.
 */
export declare function changeLogLevel(level: string): void

/**
 * A configuration structure used to specify various directories and a status report callback.
 *
 * The `Config` struct holds paths for input resources and output directories, along with optional
 * settings for debugging and compatibility. It is used to control behavior during operations such as
 * patching HKX templates, merging JSON data, and generating final outputs.
 */
export interface Config {
  /**
   * The directory containing the HKX templates you want to patch.
   *
   * Typically this is a directory like `assets/templates`. The actual patch target directory
   * should be a subdirectory such as `assets/templates/meshes`.
   */
  resourceDir: string
  /**
   * The directory where the output files will be saved.
   *
   * This directory will also contain `.debug` subdirectory if debug output is enabled.
   */
  outputDir: string
  /** Generation target */
  outputTarget: OutPutTarget
  /**
   * Enables lenient parsing for known issues in unofficial or modded patches.
   *
   * This setting allows the parser to work around common community patch errors
   * such as incorrect field names or missing values. Use with caution as it may
   * mask actual data issues.
   */
  hackOptions?: HackOptions
  /** Options controlling the output of debug artifacts. */
  debug: DebugOptions
  /**
   * Skyrim data directories glob (required **only when using FNIS**).
   *
   * This must include all directories containing `animations/<namespace>`, otherwise FNIS
   * entries will not be detected and the process will fail.
   */
  skyrimDataDirGlob?: string
}

/**
 * Converts between HKX and XML (or other supported formats) asynchronously.
 * - `inputs`: input paths
 * - `output`: output path
 * - `format`: "amd64" | "win32" | "xml" | "json". otherwise error.
 * - `roots`: inputs multiple
 * - `progress`: status report function
 *
 * # Errors
 * - Failed to convert.
 * - `FormatParse` - The provided output format string could not be parsed.
 */
export declare function convert(inputs: string[], output: string, format: "amd64" | "win32" | "xml" | "json", roots: string[] | undefined, progress: (payload: Payload) => void): Promise<void>

/** A group of flags to enable debug output of intermediate files. */
export interface DebugOptions {
  /**
   * If true, outputs the raw patch JSON to the `.debug` subdirectory under `<output_dir>/.d_merge`.
   *
   * This includes:
   * - `patch.json`: The raw parsed patch data.
   *   - For `One` patches, it reflects the result of priority-based overwriting.
   *   - For `Seq` patches, all entries are preserved in a vector (`Vec`) for later conflict resolution.
   */
  outputPatchJson: boolean
  /**
   * If true, outputs the merged JSON to the `.debug` subdirectory under `<output_dir>/.d_merge`.
   *
   * This represents the state of the data after all patches have been applied and
   * conflicts resolved, but before converting to `.hkx` format.
   */
  outputMergedJson: boolean
  /**
   * If true, outputs the intermediate merged XML to the `.debug` subdirectory under `<output_dir>/.d_merge`.
   *
   * This is the final XML representation of the patched and merged data,
   * just before conversion to the binary `.hkx` format.
   */
  outputMergedXml: boolean
}

/** Represents a node in the directory structure. */
export interface DirEntry {
  /** Relative or absolute path */
  id: string
  /** The name of the entry (file or directory). */
  label: string
  /**
   * The sub-entries contained within this directory, if applicable.
   * This will be `None` if the entry is a file.
   */
  children?: Array<DirEntry>
}

/**
 * Get the skyrim data directory.
 *
 * # Errors
 * - When the string specified in runtime is not “SkyrimSE” or “SkyrimLE”
 * - Returns an error if the Skyrim directory cannot be found from registry.
 */
export declare function getSkyrimDataDir(runtime: "SkyrimSE" | "SkyrimLE"): string

/**
 * A collection of hack options that enable non-standard parsing behavior.
 *
 * These options exist to handle cases where game mods or other tools produce
 * invalid or inconsistent data. Enabling these may allow parsing to succeed
 * in otherwise broken scenarios, at the risk of hiding real errors.
 */
export interface HackOptions {
  /**
   * Enables compatibility hacks for invalid fields in the `BSRagdollContactListenerModifier` class.
   *
   * This option activates targeted fixes for common field naming mistakes in patches:
   * - Substitutes `event` with `contactEvent`
   * - Substitutes `anotherBoneIndex` with `bones`
   */
  castRagdollEvent: boolean
}

export declare function loadDirNode(dirs: Array<string>): Promise<Array<DirEntry>>

/**
 * Collect both Nemesis and FNIS mods into a single vector.
 *
 * # Errors
 * Returns [`napi::Error`] if glob expansion fails or files cannot be read.
 */
export declare function loadModsInfo(glob: string, isVfs: boolean): Array<ModInfo>

/**
 * Logs a message at the DEBUG level.
 *
 * # Examples
 * ```ts
 * logDebug('This is a debug message');
 * ```
 */
export declare function logDebug(msg: string): void

/**
 * Logs a message at the ERROR level.
 *
 * # Examples
 * ```ts
 * logError('This is an error message');
 * ```
 */
export declare function logError(msg: string): void

/**
 * Initializes the logger with a specified directory and log file name.
 *
 * # Examples
 * ```ts
 * import path from 'node:path';
 *
 * const logDir = path.join(__dirname, 'logs');
 * loggerInit(logDir, 'node_ffi_test.log');
 * ```
 *
 * # Errors
 * An error occurs when initialization is attempted twice.
 */
export declare function loggerInit(logDir: string, logName: string): void

/**
 * Logs a message at the INFO level.
 *
 * # Examples
 * ```ts
 * logInfo('This is an info message');
 * ```
 */
export declare function logInfo(msg: string): void

/**
 * Logs a message at the TRACE level.
 *
 * # Examples
 * ```ts
 * logTrace('This is a trace message');
 * ```
 */
export declare function logTrace(msg: string): void

/**
 * Logs a message at the WARN level.
 *
 * # Examples
 * ```ts
 * logWarn('This is a warning message');
 * ```
 */
export declare function logWarn(msg: string): void

/**
 * # Note
 * - Intended `Nemesis_Engine/mods/<id>/info.ini`
 * - `priority`: As with MO2, lower numbers indicate lower priority, higher numbers indicate higher priority.
 */
export interface ModInfo {
  /** Mod-specific dir name. */
  id: string
  /** Mod name */
  name: string
  /** Mod author */
  author: string
  /** Mod download link */
  site: string
  /** Mod type. Nemesis, FNIS */
  modType: ModType
}

/** Mod type. Nemesis, FNIS */
export declare const enum ModType {
  /**
   * GUI developers must add the following to the paths array in `nemesis_merge::behavior_gen`.
   * - `<skyrim data dir>/Nemesis_Engine/mod/aaaa`
   */
  Nemesis = 'Nemesis',
  /**
   * GUI developers must add the following to the paths array in `nemesis_merge::behavior_gen`.
   * - `<skyrim data dir>/meshes/actors/character/animations/<namespace>`
   */
  Fnis = 'Fnis'
}

/** Behavior Output target */
export declare const enum OutPutTarget {
  /** Skyrim Legendary Edition */
  SkyrimSE = 'SkyrimSE',
  /** Skyrim Special Edition */
  SkyrimLE = 'SkyrimLE'
}

/** Mod entries */
export interface PatchMaps {
  /**
   * Nemesis patch path
   * - key: path until mod_code(e.g. `<skyrim_data_dir>/meshes/Nemesis_Engine/mod/slide`)
   * - value: priority
   */
  nemesisEntries: Record<string, number>
  /**
   * FNIS patch path
   * - key: FNIS namespace(e.g. `namespace` of `<skyrim_data_dir>/path/meshes/actors/character/animations/<namespace>`)
   * - value: priority
   */
  fnisEntries: Record<string, number>
}

/**
 * Represents the status of a patching process.
 *
 * This struct is used to report the current state of the process. Depending on the `event`,
 * `content` may contain progress information, and `err_msg` may contain an error message if the process failed.
 *
 * The backend emits these status values using `window.emit(...)` during various stages.
 * - Mirrors Rust enum with serde(tag="type", content="content").
 */
export type PatchStatus =
  | { type: 'GeneratingFnisPatches', /** 0 based index */
index: number, total: number }
| { type: 'ReadingPatches', /** 0 based index */
index: number, total: number }
| { type: 'ParsingPatches', /** 0 based index */
index: number, total: number }
| { type: 'ApplyingPatches', /** 0 based index */
index: number, total: number }
| { type: 'GeneratingHkxFiles', /** 0 based index */
index: number, total: number }
| { type: 'Done' }
| { type: 'Error', field0: string }

/** Payload for progress reporting */
export interface Payload {
  /**
   * Hashed identifier of the file path.
   *
   * Using a hash ensures that the frontend can track tasks reliably,
   * even if items are removed or reordered.
   *
   * - conversion input path to `djb2` hashed -> id
   */
  pathId: number
  /** Current progress status of this task. */
  status: SerdeHkxStatus
}

/** Represents the progress of a task, including index and total count. */
export interface ProgressContent {
  /** Current index of the progress. */
  index: number
  /** Total count for the progress. */
  total: number
}

/**
 * Represents the progress status of a conversion task.
 *
 * The numeric representation (`u8`) is serialized and deserialized directly,
 * which is convenient for frontend communication.
 */
export declare const enum SerdeHkxStatus {
  /** Task is pending and has not started yet.: 0 */
  Pending = 0,
  /** Task is currently being processed.: 1 */
  Processing = 1,
  /** Task completed successfully.: 2 */
  Done = 2,
  /** Task encountered an error during processing.: 3 */
  Error = 3
}
